<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>PSDataColumn</Name>
    <Members>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new DataColumn.
.DESCRIPTION
    Creates a new DataColumn object.

    DataColumns are used to define the schema of a DataTable.
    
    They define the name, data type, and properties of a column in a DataTable.
#&gt;
param(
# The name of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('Name')]
[string]
$ColumnName,

# The data type of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('ParameterType','Type','DataType')]
[psobject]
$ColumnType,

# The expression used to create the column.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('Expr')]
[string]
$Expression,

# The mapping type of the column (either an attribute or an element).
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('MappingType')]
[Data.MappingType]
$ColumnMapping,

# If set, the column will auto-increment.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$AutoIncrement,

# The seed value for the auto-increment.  This is the starting value.
[Parameter(ValueFromPipelineByPropertyName)]
[long]
$AutoIncrementSeed,

# The step value for the auto-increment.  This is the amount to increment by.
[Parameter(ValueFromPipelineByPropertyName)]
[long]
$AutoIncrementStep,

# The caption of the column.  This can be used by a designer.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$Caption,

# The default value of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[object]
$DefaultValue,

# The max length of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[int]
$MaxLength,

# The namespace of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$Namespace,

# The prefix of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$Prefix,

# If set, the column items must be unique.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$Unique,

# If set, the column is read-only.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$ReadOnly
)

process {    
    $myParams = [Ordered]@{} + $PSBoundParameters

    $realDataType = 
        if ($ColumnType -is [type]) {
            if ($ColumnType -eq [switch]) {
                [bool]
            } 
            elseif ($ColumnType -eq [IO.FileInfo]) {
                [string]                
            }
            else {
                $ColumnType
            }            
        } elseif ($ColumnType -in 'number','double','single','float') {
            [double]
        } else {
            [object]
        }

    $constructorArguments = @(
        if ($ColumnName) {$ColumnName}
        else {''}

        $realDataType

        if ($Expression) {
            $Expression
            if ($ColumnMapping) { $ColumnMapping }
        }
        else {
            if ($ColumnMapping) {"", $ColumnMapping}
        }        
    )

    $dataColumn = [Data.DataColumn]::new.Invoke($constructorArguments)
    if (-not $dataColumn) { return }


    
    foreach ($myParam in $myParams.GetEnumerator()) {
        $dataPropertyInfo = [Data.DataColumn].GetProperty($myParam.Key)
        if ($dataPropertyInfo.CanWrite) {
            $dataPropertyInfo.SetValue($dataColumn, $myParam.Value -as $dataPropertyInfo.PropertyType)
        }
    }    

    $dataColumn
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the name of the table.
.DESCRIPTION
    Gets the name of the table that the column belongs to.
#&gt;
$this.Table.TableName

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataColumn</Name>
    <Members>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new DataColumn.
.DESCRIPTION
    Creates a new DataColumn object.

    DataColumns are used to define the schema of a DataTable.
    
    They define the name, data type, and properties of a column in a DataTable.
#&gt;
param(
# The name of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('Name')]
[string]
$ColumnName,

# The data type of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('ParameterType','Type','DataType')]
[psobject]
$ColumnType,

# The expression used to create the column.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('Expr')]
[string]
$Expression,

# The mapping type of the column (either an attribute or an element).
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('MappingType')]
[Data.MappingType]
$ColumnMapping,

# If set, the column will auto-increment.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$AutoIncrement,

# The seed value for the auto-increment.  This is the starting value.
[Parameter(ValueFromPipelineByPropertyName)]
[long]
$AutoIncrementSeed,

# The step value for the auto-increment.  This is the amount to increment by.
[Parameter(ValueFromPipelineByPropertyName)]
[long]
$AutoIncrementStep,

# The caption of the column.  This can be used by a designer.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$Caption,

# The default value of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[object]
$DefaultValue,

# The max length of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[int]
$MaxLength,

# The namespace of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$Namespace,

# The prefix of the column.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$Prefix,

# If set, the column items must be unique.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$Unique,

# If set, the column is read-only.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$ReadOnly
)

process {    
    $myParams = [Ordered]@{} + $PSBoundParameters

    $realDataType = 
        if ($ColumnType -is [type]) {
            if ($ColumnType -eq [switch]) {
                [bool]
            } 
            elseif ($ColumnType -eq [IO.FileInfo]) {
                [string]                
            }
            else {
                $ColumnType
            }            
        } elseif ($ColumnType -in 'number','double','single','float') {
            [double]
        } else {
            [object]
        }

    $constructorArguments = @(
        if ($ColumnName) {$ColumnName}
        else {''}

        $realDataType

        if ($Expression) {
            $Expression
            if ($ColumnMapping) { $ColumnMapping }
        }
        else {
            if ($ColumnMapping) {"", $ColumnMapping}
        }        
    )

    $dataColumn = [Data.DataColumn]::new.Invoke($constructorArguments)
    if (-not $dataColumn) { return }


    
    foreach ($myParam in $myParams.GetEnumerator()) {
        $dataPropertyInfo = [Data.DataColumn].GetProperty($myParam.Key)
        if ($dataPropertyInfo.CanWrite) {
            $dataPropertyInfo.SetValue($dataColumn, $myParam.Value -as $dataPropertyInfo.PropertyType)
        }
    }    

    $dataColumn
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the name of the table.
.DESCRIPTION
    Gets the name of the table that the column belongs to.
#&gt;
$this.Table.TableName

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSDataCommand</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data commands
.DESCRIPTION
    Gets loaded data commands.
.NOTES
    Will only get commands that have been saved to a variable, and are a `[Data.Common.DbCommand]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbCommand]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>DataCommand</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data commands
.DESCRIPTION
    Gets loaded data commands.
.NOTES
    Will only get commands that have been saved to a variable, and are a `[Data.Common.DbCommand]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbCommand]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.Common.DbCommand</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data commands
.DESCRIPTION
    Gets loaded data commands.
.NOTES
    Will only get commands that have been saved to a variable, and are a `[Data.Common.DbCommand]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbCommand]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>PSDataConnection</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data connections
.DESCRIPTION
    Gets loaded data connections.
.NOTES
    Will only get connections that have been saved to a variable, and are a `[Data.Common.DbConnection]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbConnection]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new connection to a data source
.DESCRIPTION
    Creates a new connection to a data source (usually a database).

    By default, this tries to use the `System.Data.SqlClient.SqlConnection` type.
    
    An alternate typename can be specified by providing the `-ConnectionTypeName` parameter.
#&gt;
param(
# The connection secret (or connection string, if you are brave).
# If a secret is provided, it will be used to retrieve the connection string.
# This will require the Microsoft.PowerShell.SecretManagement module.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('ConnectionString', 'ConnectionStringOrSecret')]
[string]
$ConnectionSecret,

# The name of the vault to use to retrieve the connection secret.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$VaultName,

# The type name of connection type.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$ConnectionTypeName,

# The assembly location of the data adapter to use.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('AssemblyPath')]
[string]
$AssemblyLocation
)

if (-not $connectionTypeName) {
    $connectionTypeName = 'System.Data.SqlClient.SqlConnection'
}
if (-not ($ConnectionTypeName -as [type])) {
    if ($AssemblyLocation) {
        Add-Type -Path $AssemblyLocation
    }    
}

$connectionType = $connectionTypeName -as [type]
if (-not $connectionType -or -not $connectionType.GetConstructors()) {
    throw "Unable to create an instance of $connectionType"
}

$ConnectionString = 
    if ($connectionSecret -match '\;') {
        $connectionSecret
    } else {
        $secretSplat = [Ordered]@{Name=$ConnectionSecret}
        if ($VaultName) {
            $secretSplat.VaultName = $VaultName
        }
        Get-Secret @secretSplat -AsPlainText
    }

$connectionType::new($connectionString)

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.Common.DbConnection</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data connections
.DESCRIPTION
    Gets loaded data connections.
.NOTES
    Will only get connections that have been saved to a variable, and are a `[Data.Common.DbConnection]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbConnection]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new connection to a data source
.DESCRIPTION
    Creates a new connection to a data source (usually a database).

    By default, this tries to use the `System.Data.SqlClient.SqlConnection` type.
    
    An alternate typename can be specified by providing the `-ConnectionTypeName` parameter.
#&gt;
param(
# The connection secret (or connection string, if you are brave).
# If a secret is provided, it will be used to retrieve the connection string.
# This will require the Microsoft.PowerShell.SecretManagement module.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('ConnectionString', 'ConnectionStringOrSecret')]
[string]
$ConnectionSecret,

# The name of the vault to use to retrieve the connection secret.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$VaultName,

# The type name of connection type.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$ConnectionTypeName,

# The assembly location of the data adapter to use.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('AssemblyPath')]
[string]
$AssemblyLocation
)

if (-not $connectionTypeName) {
    $connectionTypeName = 'System.Data.SqlClient.SqlConnection'
}
if (-not ($ConnectionTypeName -as [type])) {
    if ($AssemblyLocation) {
        Add-Type -Path $AssemblyLocation
    }    
}

$connectionType = $connectionTypeName -as [type]
if (-not $connectionType -or -not $connectionType.GetConstructors()) {
    throw "Unable to create an instance of $connectionType"
}

$ConnectionString = 
    if ($connectionSecret -match '\;') {
        $connectionSecret
    } else {
        $secretSplat = [Ordered]@{Name=$ConnectionSecret}
        if ($VaultName) {
            $secretSplat.VaultName = $VaultName
        }
        Get-Secret @secretSplat -AsPlainText
    }

$connectionType::new($connectionString)

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>PSDataSet</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets the data sets
.DESCRIPTION
    Gets the data sets from the current session.
.EXAMPLE
    Get-PSDataSet
.EXAMPLE
    ([PSCustomObject]@{PSTypeName='PSDataSet'}).Get()
#&gt;
param()
foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.DataSet]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the table names
.DESCRIPTION
    Gets the table names from the data set.
.NOTES
    When the table names are enumerated, they are added as properties to the data set.
    This makes it easier to access tables by name.
#&gt;
@(foreach ($dataTable in $this.Tables) {
    $dataTable.TableName
    if (-not $this.psobject.properties[$dataTable.TableName]) {
        $this.psobject.properties.Add([psnoteproperty]::new($dataTable.TableName, $dataTable), $true)
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataSet</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets the data sets
.DESCRIPTION
    Gets the data sets from the current session.
.EXAMPLE
    Get-PSDataSet
.EXAMPLE
    ([PSCustomObject]@{PSTypeName='PSDataSet'}).Get()
#&gt;
param()
foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.DataSet]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the table names
.DESCRIPTION
    Gets the table names from the data set.
.NOTES
    When the table names are enumerated, they are added as properties to the data set.
    This makes it easier to access tables by name.
#&gt;
@(foreach ($dataTable in $this.Tables) {
    $dataTable.TableName
    if (-not $this.psobject.properties[$dataTable.TableName]) {
        $this.psobject.properties.Add([psnoteproperty]::new($dataTable.TableName, $dataTable), $true)
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSDataTable</Name>
    <Members>
      <AliasProperty>
        <Name>Count</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Length</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Subscribers</Name>
        <ReferencedMemberName>Subscriber</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Import</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports data into a data table
.DESCRIPTION
    Imports data into a data table.
.NOTES
    If columns do not yet exist, they will be created based on the properties of the input objects.
#&gt;
param()

# Collect all input rows (arguments and piped input)
$arguments = @($args)
$pipedInput = @($input)

$allInputRows = @(
    $arguments | . { process { $_} }
    $pipedInput | . { process { $_} }
)

# If this was not a table
$aTable = $this
if ($aTable -isnot [Data.DataTable]) {
    # make a table.
    $aTable = [Data.DataTable]::new()
}

# Walk over each row in the table.
:nextRow foreach ($inputRow in $allInputRows) {
    if ($inputRow -is [Data.DataColumn]) {
        $null = $aTable.Columns.Add($inputRow)
        continue nextRow
    }    
    $newInputRow = $aTable.NewRow()
    $inputRowTypeNames = $inputRow.pstypenames
    :nextProperty foreach ($rowProperty in $inputRow.psobject.properties) {
        # Skip static properties from the extended type system
        if (-not $rowProperty.IsInstance) { continue nextProperty }

        if ($aTable.Columns.Count -and $aTable.Columns[$rowProperty.Name]) {
            try {
                $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
            } catch {
                $ex = $_
                Write-Warning "Failed to set value for $($rowProperty.Name): $ex"
            }
            
            continue nextProperty
        }
        
        if ($null -ne $rowProperty.Value) {
            $rowPropertyType = $rowProperty.Value.GetType()
            if ($rowPropertyType.FullName -match '\.PS(?:Custom)Object') {
                $rowPropertyType = [object]
            }
            
            $null = $aTable.Columns.Add($rowProperty.Name, $rowPropertyType)
        } else {
            $null = $aTable.Columns.Add($rowProperty.Name, [object])
        }

        $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
    }    
    $null = $aTable.Rows.Add($newInputRow)
}
$aTable.AcceptChanges()
return ,$aTable
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>CLIXML</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a data table as Clixml
.DESCRIPTION
    Gets a Clixml representation of the rows in a data table.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
[Management.Automation.PSSerializer]::Serialize(
    @($this | Select-Object -Property $columnNames), $FormatEnumerationLimit
)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        return $this.Columns.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>InputScript</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the input script for a DataTable.
.DESCRIPTION
    Dynamically creates a script block that can be used to add rows to a datatable from the pipeline.
#&gt;

param($this = $this)
if (-not $this) { return}
$extendedProperties = [Ordered]@{} + $this.ExtendedProperties
$parameterBlock = @(
    foreach ($dataColumn in $this.Columns) {
        if ($dataColumn.ReadOnly) { continue }
        @(
            $helpLines = $(
                if ($dataColumn.Caption) { $dataColumn.Caption }
                else { $dataColumn.ColumnName }
            ) -split "(?&gt;\r\n|\n)"

            foreach ($helpLine in $helpLines) {                
                "# $helpLine"
            }
            '[Parameter(ValueFromPipelineByPropertyName)]'
            if ($extendedProperties.Aliases -and $extendedProperties.Aliases[$dataColumn.ColumnName] )  {
                "[Alias('$($extendedProperties.Aliases[$dataColumn.ColumnName] -join "','")')]"
            }
            if ($extendedProperties.Patterns -and $extendedProperties.Patterns[$dataColumn.ColumnName]) {
                "[ValidatePattern('$($extendedProperties.Patterns[$dataColumn.ColumnName] -replace "'", "''")')]"
            }
            if ($extendedProperties.Validators -and $extendedProperties.Validators[$dataColumn.ColumnName]) {
                "[ValidateScript({$($extendedProperties.Validators[$dataColumn.ColumnName])})]"
            }
            "[$($dataColumn.DataType.FullName -replace '^System\.')]"
            "`${$($dataColumn.ColumnName)}"
        ) -join [Environment]::NewLine
    }
    @(
        '[Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline,Position=0)]'
        '[PSObject[]]'
        '$InputObject'
    ) -join [Environment]::NewLine
) -join (',' + [Environment]::NewLine)
    
$newScriptBlock = ([ScriptBlock]::Create(@"
[CmdletBinding(PositionalBinding=`$false)]
param(
$parameterBlock
)

process {$({
    $myCommandMetadata = [Management.Automation.CommandMetadata]$MyInvocation.MyCommand
    if ($myInvocation.MyCommand.ScriptBlock.ThisIs) {
        $local:this = $myInvocation.MyCommand.ScriptBlock.ThisIs
    }
        
    $inputObjects = @($input)
    if (-not $inputObjects -and $inputObject.Length) { $inputObjects = $inputObject }
    if (-not $inputObjects) {
        $inputObjects = @([PSCustomObject]([Ordered]@{} + $PSBoundParameters))
    }

    foreach ($inObject in $inputObjects) {
        $newRow   = if ($local:this -is [Data.DataTable]) {
            $local:this.NewRow()
        }
        foreach ($myParameterName in @($myCommandMetadata.Parameters.Keys)) {         
            if ($newRow.Table -and $newRow.Table.Columns[$myParameterName]) {
                $newRow[$myParameterName] = $inObject.$myParameterName -as $newRow.Table.Columns[$myParameterName].DataType
            }
        }
        if ($newRow) {
            $null = $newRow.Table.Rows.Add($newRow)
        }
        $inObject
    }
})
}
"@))
$newScriptBlock.psobject.properties.add([psnoteproperty]::new('ThisIs', $this), $true)
    
return $newScriptBlock



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>JSON</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a data table as JSON
.DESCRIPTION
    Gets a JSON representation of a data table
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | ConvertTo-Json -Depth $FormatEnumerationLimit
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>JSONL</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a datatable as JSONL
.DESCRIPTION
    Gets a JSONL representation of a data table
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | . {process { $_  | ConvertTo-Json -Compress -Depth $FormatEnumerationLimit } }
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        return $this.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Schema.json</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as a [JSON schema](https://json-schema.org/).
#&gt;
$jsonSchema = [Ordered]@{
    type = 'object'
    properties = [Ordered]@{}
}
foreach ($column in $this.Columns) {
    $jsonSchema.properties[$column.ColumnName] = [Ordered]@{        
        type = switch ($column.DataType) {
            {$_ -eq [System.String]} { 'string' }
            {$_ -eq [System.Int32]} { 'integer' }
            {$_ -eq [System.Int64]} { 'integer' }
            {$_ -in [Double], [float]} { 'number' }
            {$_ -eq [DateTime]} { 'string' }
            {$_ -eq [Boolean], [switch]} { 'boolean' }
            {$_.IsEnum} { 'enum' }
            default { 'object' }
        }        
    }
    if ($column.DefaultValue -ne [System.DBNull]::Value) {
        $jsonSchema.properties[$column.ColumnName].default = $column.DefaultValue
    }
    if ($column.Caption) {
        $jsonSchema.properties[$column.ColumnName].description = $column.Caption
    }
}
return ($jsonSchema | ConvertTo-Json -Depth 10)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Subscriber</Name>
        <GetScriptBlock>
                        param()

@(foreach ($eventSubscriber in Get-EventSubscriber) {
    if ($eventSubscriber.SourceObject.GetHashCode() -eq $this.GetHashCode()) {        
        $eventSubscriber
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>XML</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as XML
.DESCRIPTION
    Gets a DataTable as XML, using the `WriteXml` method.
.NOTES
    This property will only return the XML representation of simple DataTables, whose columns are all of simple types.
    
    If this errors out, because it is a property it will simply return nothing.

    To examine the errors, look at `$Error`.
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WriteXml($stringWriter)
$xml = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xml

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>XSD</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as an XML Schema Definition (`.xsd`).
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WritexmlSchema($stringWriter)
$xsd = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xsd

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataTable</Name>
    <Members>
      <AliasProperty>
        <Name>Count</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Length</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Subscribers</Name>
        <ReferencedMemberName>Subscriber</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Import</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports data into a data table
.DESCRIPTION
    Imports data into a data table.
.NOTES
    If columns do not yet exist, they will be created based on the properties of the input objects.
#&gt;
param()

# Collect all input rows (arguments and piped input)
$arguments = @($args)
$pipedInput = @($input)

$allInputRows = @(
    $arguments | . { process { $_} }
    $pipedInput | . { process { $_} }
)

# If this was not a table
$aTable = $this
if ($aTable -isnot [Data.DataTable]) {
    # make a table.
    $aTable = [Data.DataTable]::new()
}

# Walk over each row in the table.
:nextRow foreach ($inputRow in $allInputRows) {
    if ($inputRow -is [Data.DataColumn]) {
        $null = $aTable.Columns.Add($inputRow)
        continue nextRow
    }    
    $newInputRow = $aTable.NewRow()
    $inputRowTypeNames = $inputRow.pstypenames
    :nextProperty foreach ($rowProperty in $inputRow.psobject.properties) {
        # Skip static properties from the extended type system
        if (-not $rowProperty.IsInstance) { continue nextProperty }

        if ($aTable.Columns.Count -and $aTable.Columns[$rowProperty.Name]) {
            try {
                $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
            } catch {
                $ex = $_
                Write-Warning "Failed to set value for $($rowProperty.Name): $ex"
            }
            
            continue nextProperty
        }
        
        if ($null -ne $rowProperty.Value) {
            $rowPropertyType = $rowProperty.Value.GetType()
            if ($rowPropertyType.FullName -match '\.PS(?:Custom)Object') {
                $rowPropertyType = [object]
            }
            
            $null = $aTable.Columns.Add($rowProperty.Name, $rowPropertyType)
        } else {
            $null = $aTable.Columns.Add($rowProperty.Name, [object])
        }

        $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
    }    
    $null = $aTable.Rows.Add($newInputRow)
}
$aTable.AcceptChanges()
return ,$aTable
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>CLIXML</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a data table as Clixml
.DESCRIPTION
    Gets a Clixml representation of the rows in a data table.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
[Management.Automation.PSSerializer]::Serialize(
    @($this | Select-Object -Property $columnNames), $FormatEnumerationLimit
)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        return $this.Columns.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>InputScript</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the input script for a DataTable.
.DESCRIPTION
    Dynamically creates a script block that can be used to add rows to a datatable from the pipeline.
#&gt;

param($this = $this)
if (-not $this) { return}
$extendedProperties = [Ordered]@{} + $this.ExtendedProperties
$parameterBlock = @(
    foreach ($dataColumn in $this.Columns) {
        if ($dataColumn.ReadOnly) { continue }
        @(
            $helpLines = $(
                if ($dataColumn.Caption) { $dataColumn.Caption }
                else { $dataColumn.ColumnName }
            ) -split "(?&gt;\r\n|\n)"

            foreach ($helpLine in $helpLines) {                
                "# $helpLine"
            }
            '[Parameter(ValueFromPipelineByPropertyName)]'
            if ($extendedProperties.Aliases -and $extendedProperties.Aliases[$dataColumn.ColumnName] )  {
                "[Alias('$($extendedProperties.Aliases[$dataColumn.ColumnName] -join "','")')]"
            }
            if ($extendedProperties.Patterns -and $extendedProperties.Patterns[$dataColumn.ColumnName]) {
                "[ValidatePattern('$($extendedProperties.Patterns[$dataColumn.ColumnName] -replace "'", "''")')]"
            }
            if ($extendedProperties.Validators -and $extendedProperties.Validators[$dataColumn.ColumnName]) {
                "[ValidateScript({$($extendedProperties.Validators[$dataColumn.ColumnName])})]"
            }
            "[$($dataColumn.DataType.FullName -replace '^System\.')]"
            "`${$($dataColumn.ColumnName)}"
        ) -join [Environment]::NewLine
    }
    @(
        '[Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline,Position=0)]'
        '[PSObject[]]'
        '$InputObject'
    ) -join [Environment]::NewLine
) -join (',' + [Environment]::NewLine)
    
$newScriptBlock = ([ScriptBlock]::Create(@"
[CmdletBinding(PositionalBinding=`$false)]
param(
$parameterBlock
)

process {$({
    $myCommandMetadata = [Management.Automation.CommandMetadata]$MyInvocation.MyCommand
    if ($myInvocation.MyCommand.ScriptBlock.ThisIs) {
        $local:this = $myInvocation.MyCommand.ScriptBlock.ThisIs
    }
        
    $inputObjects = @($input)
    if (-not $inputObjects -and $inputObject.Length) { $inputObjects = $inputObject }
    if (-not $inputObjects) {
        $inputObjects = @([PSCustomObject]([Ordered]@{} + $PSBoundParameters))
    }

    foreach ($inObject in $inputObjects) {
        $newRow   = if ($local:this -is [Data.DataTable]) {
            $local:this.NewRow()
        }
        foreach ($myParameterName in @($myCommandMetadata.Parameters.Keys)) {         
            if ($newRow.Table -and $newRow.Table.Columns[$myParameterName]) {
                $newRow[$myParameterName] = $inObject.$myParameterName -as $newRow.Table.Columns[$myParameterName].DataType
            }
        }
        if ($newRow) {
            $null = $newRow.Table.Rows.Add($newRow)
        }
        $inObject
    }
})
}
"@))
$newScriptBlock.psobject.properties.add([psnoteproperty]::new('ThisIs', $this), $true)
    
return $newScriptBlock



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>JSON</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a data table as JSON
.DESCRIPTION
    Gets a JSON representation of a data table
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | ConvertTo-Json -Depth $FormatEnumerationLimit
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>JSONL</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a datatable as JSONL
.DESCRIPTION
    Gets a JSONL representation of a data table
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | . {process { $_  | ConvertTo-Json -Compress -Depth $FormatEnumerationLimit } }
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        return $this.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Schema.json</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as a [JSON schema](https://json-schema.org/).
#&gt;
$jsonSchema = [Ordered]@{
    type = 'object'
    properties = [Ordered]@{}
}
foreach ($column in $this.Columns) {
    $jsonSchema.properties[$column.ColumnName] = [Ordered]@{        
        type = switch ($column.DataType) {
            {$_ -eq [System.String]} { 'string' }
            {$_ -eq [System.Int32]} { 'integer' }
            {$_ -eq [System.Int64]} { 'integer' }
            {$_ -in [Double], [float]} { 'number' }
            {$_ -eq [DateTime]} { 'string' }
            {$_ -eq [Boolean], [switch]} { 'boolean' }
            {$_.IsEnum} { 'enum' }
            default { 'object' }
        }        
    }
    if ($column.DefaultValue -ne [System.DBNull]::Value) {
        $jsonSchema.properties[$column.ColumnName].default = $column.DefaultValue
    }
    if ($column.Caption) {
        $jsonSchema.properties[$column.ColumnName].description = $column.Caption
    }
}
return ($jsonSchema | ConvertTo-Json -Depth 10)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Subscriber</Name>
        <GetScriptBlock>
                        param()

@(foreach ($eventSubscriber in Get-EventSubscriber) {
    if ($eventSubscriber.SourceObject.GetHashCode() -eq $this.GetHashCode()) {        
        $eventSubscriber
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>XML</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as XML
.DESCRIPTION
    Gets a DataTable as XML, using the `WriteXml` method.
.NOTES
    This property will only return the XML representation of simple DataTables, whose columns are all of simple types.
    
    If this errors out, because it is a property it will simply return nothing.

    To examine the errors, look at `$Error`.
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WriteXml($stringWriter)
$xml = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xml

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>XSD</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as an XML Schema Definition (`.xsd`).
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WritexmlSchema($stringWriter)
$xsd = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xsd

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>