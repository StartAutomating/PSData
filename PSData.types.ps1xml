<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>PSDataColumn</Name>
    <Members>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the name of the table.
.DESCRIPTION
    Gets the name of the table that the column belongs to.
#&gt;
$this.Table.TableName

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataColumn</Name>
    <Members>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the name of the table.
.DESCRIPTION
    Gets the name of the table that the column belongs to.
#&gt;
$this.Table.TableName

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSDataCommand</Name>
    <Members>
    </Members>
  </Type>
  <Type>
    <Name>DataCommand</Name>
    <Members>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.Common.DbCommand</Name>
    <Members>
    </Members>
  </Type>
  <Type>
    <Name>PSDataConnection</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data connections
.DESCRIPTION
    Gets loaded data connections.
.NOTES
    Will only get connections that have been saved to a variable, and are a `[Data.Common.DbConnection]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbConnection]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new connection to a data source
.DESCRIPTION
    Creates a new connection to a data source (usually a database).

    By default, this tries to use the `System.Data.SqlClient.SqlConnection` type.
    
    An alternate typename can be specified by providing the `-ConnectionTypeName` parameter.
#&gt;
param(
# The connection secret (or connection string, if you are brave).
# If a secret is provided, it will be used to retrieve the connection string.
# This will require the Microsoft.PowerShell.SecretManagement module.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('ConnectionString', 'ConnectionStringOrSecret')]
[string]
$ConnectionSecret,

# The name of the vault to use to retrieve the connection secret.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$VaultName,

# The type name of connection type.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$ConnectionTypeName,

# The assembly location of the data adapter to use.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('AssemblyPath')]
[string]
$AssemblyLocation
)

if (-not $connectionTypeName) {
    $connectionTypeName = 'System.Data.SqlClient.SqlConnection'
}
if (-not ($ConnectionTypeName -as [type])) {
    if ($AssemblyLocation) {
        Add-Type -Path $AssemblyLocation
    }    
}

$connectionType = $connectionTypeName -as [type]
if (-not $connectionType -or -not $connectionType.GetConstructors()) {
    throw "Unable to create an instance of $connectionType"
}

$ConnectionString = 
    if ($connectionSecret -match '\;') {
        $connectionSecret
    } else {
        $secretSplat = [Ordered]@{Name=$ConnectionSecret}
        if ($VaultName) {
            $secretSplat.VaultName = $VaultName
        }
        Get-Secret @secretSplat -AsPlainText
    }

$connectionType::new($connectionString)

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.Common.DbConnection</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets data connections
.DESCRIPTION
    Gets loaded data connections.
.NOTES
    Will only get connections that have been saved to a variable, and are a `[Data.Common.DbConnection]`.
#&gt;
param()

foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.Common.DbConnection]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new connection to a data source
.DESCRIPTION
    Creates a new connection to a data source (usually a database).

    By default, this tries to use the `System.Data.SqlClient.SqlConnection` type.
    
    An alternate typename can be specified by providing the `-ConnectionTypeName` parameter.
#&gt;
param(
# The connection secret (or connection string, if you are brave).
# If a secret is provided, it will be used to retrieve the connection string.
# This will require the Microsoft.PowerShell.SecretManagement module.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('ConnectionString', 'ConnectionStringOrSecret')]
[string]
$ConnectionSecret,

# The name of the vault to use to retrieve the connection secret.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$VaultName,

# The type name of connection type.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$ConnectionTypeName,

# The assembly location of the data adapter to use.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('AssemblyPath')]
[string]
$AssemblyLocation
)

if (-not $connectionTypeName) {
    $connectionTypeName = 'System.Data.SqlClient.SqlConnection'
}
if (-not ($ConnectionTypeName -as [type])) {
    if ($AssemblyLocation) {
        Add-Type -Path $AssemblyLocation
    }    
}

$connectionType = $connectionTypeName -as [type]
if (-not $connectionType -or -not $connectionType.GetConstructors()) {
    throw "Unable to create an instance of $connectionType"
}

$ConnectionString = 
    if ($connectionSecret -match '\;') {
        $connectionSecret
    } else {
        $secretSplat = [Ordered]@{Name=$ConnectionSecret}
        if ($VaultName) {
            $secretSplat.VaultName = $VaultName
        }
        Get-Secret @secretSplat -AsPlainText
    }

$connectionType::new($connectionString)

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>PSDataSet</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets the data sets
.DESCRIPTION
    Gets the data sets from the current session.
.EXAMPLE
    Get-PSDataSet
.EXAMPLE
    ([PSCustomObject]@{PSTypeName='PSDataSet'}).Get()
#&gt;
param()
foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.DataSet]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>InputScript</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the input scripts for the data set
.DESCRIPTION
    Gets the input scripts for the current data set.

    Only uniquely named tables will be included in the output.
#&gt;
$inputScripts = [Ordered]@{}
foreach ($table in $this.Tables) {    
    if (-not $table.TableName) {
        continue
    }
    $inputScripts[$table.TableName] = $table.InputScript
}
return $inputScripts
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the table names
.DESCRIPTION
    Gets the table names from the data set.
.NOTES
    When the table names are enumerated, they are added as properties to the data set.
    This makes it easier to access tables by name.
#&gt;
@(foreach ($dataTable in $this.Tables) {
    $dataTable.TableName
    if (-not $this.psobject.properties[$dataTable.TableName]) {
        $this.psobject.properties.Add([psnoteproperty]::new($dataTable.TableName, $dataTable), $true)
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataSet</Name>
    <Members>
      <ScriptMethod>
        <Name>Get</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets the data sets
.DESCRIPTION
    Gets the data sets from the current session.
.EXAMPLE
    Get-PSDataSet
.EXAMPLE
    ([PSCustomObject]@{PSTypeName='PSDataSet'}).Get()
#&gt;
param()
foreach ($variable in @(Get-Variable)) {
    if ($variable.Value -is [Data.DataSet]) {
        $variable.Value
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>InputScript</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the input scripts for the data set
.DESCRIPTION
    Gets the input scripts for the current data set.

    Only uniquely named tables will be included in the output.
#&gt;
$inputScripts = [Ordered]@{}
foreach ($table in $this.Tables) {    
    if (-not $table.TableName) {
        continue
    }
    $inputScripts[$table.TableName] = $table.InputScript
}
return $inputScripts
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the table names
.DESCRIPTION
    Gets the table names from the data set.
.NOTES
    When the table names are enumerated, they are added as properties to the data set.
    This makes it easier to access tables by name.
#&gt;
@(foreach ($dataTable in $this.Tables) {
    $dataTable.TableName
    if (-not $this.psobject.properties[$dataTable.TableName]) {
        $this.psobject.properties.Add([psnoteproperty]::new($dataTable.TableName, $dataTable), $true)
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSDataTable</Name>
    <Members>
      <AliasProperty>
        <Name>Count</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Length</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Subscribers</Name>
        <ReferencedMemberName>Subscriber</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Import</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports data into a data table
.DESCRIPTION
    Imports data into a data table.
.NOTES
    If columns do not yet exist, they will be created based on the properties of the input objects.
#&gt;
param()

# Collect all input rows (arguments and piped input)
$arguments = @($args)
$pipedInput = @($input)

$allInputRows = @() + $arguments + $pipedInput

# If this was not a table
$aTable = $this
if ($aTable -isnot [Data.DataTable]) {
    # make a table.
    $aTable = [Data.DataTable]::new()
}

# Walk over each unrolled row in the table.
:nextRow foreach ($inputRow in $allInputRows | . { process { $_}}) {
    # Skip empty values.
    if ($null -eq $inputRow -or [DBNull]::Value -eq $inputRow) { continue nextRow }
    # If a "row" was really a column, add it to the table.
    if ($inputRow -is [Data.DataColumn]) {
        $null = $aTable.Columns.Add($inputRow)
        continue nextRow
    }
    $newInputRow = $aTable.NewRow()
    # If it was already a .NET DataRow, add it to the table.
    if ($inputRow -is [Data.DataRow]) {
        # Of course, don't forget to add it's columns, first.
        foreach ($column in $inputRow.Table.Columns) {
            if (-not ($aTable.Columns.Count -and $aTable.Columns[$column.ColumnName])) {
                $null = $aTable.Columns.Add($column.ColumnName, $column.DataType)    
            }
            $columnAsType = $inputRow[$column.ColumnName] -as $aTable.Columns[$column.ColumnName].DataType
            if (-not $columnAsType) { $columnAsType = [DBNull]::Value }
            $newInputRow[$column.ColumnName] = $columnAsType
        }
        $null = $aTable.Rows.Add($newInputRow)
        continue nextRow
    }
    
    $inputRowTypeNames = $inputRow.pstypenames
    :nextProperty foreach ($rowProperty in $inputRow.psobject.properties) {
        # Skip static properties from the extended type system
        if (-not $rowProperty.IsInstance) { continue nextProperty }

        if ($aTable.Columns.Count -and $aTable.Columns[$rowProperty.Name]) {
            try {
                $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
            } catch {
                $ex = $_
                Write-Warning "Failed to set value for $($rowProperty.Name): $ex"
            }
            
            continue nextProperty
        }
        
        if ($null -ne $rowProperty.Value) {
            $rowPropertyType = $rowProperty.Value.GetType()
            if ($rowPropertyType.FullName -match '\.PS(?:Custom)Object') {
                $rowPropertyType = [object]
            }
            
            $null = $aTable.Columns.Add($rowProperty.Name, $rowPropertyType)
        } else {
            $null = $aTable.Columns.Add($rowProperty.Name, [object])
        }

        $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
    }    
    $null = $aTable.Rows.Add($newInputRow)
}
$aTable.AcceptChanges()
return ,$aTable
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new table
.DESCRIPTION
    Creates a new data table.
#&gt;
param(
# The name of the table.
[string]
$TableName,

# The namespace of the table.
[string]
$TableNamespace,

# The prefix of the table.
# This is used to shorten references to the table if is serialized to XML.
[string]
$TablePrefix,

# The columns of the table.
[Alias('Columns')]
[PSObject[]]
$Column,

# The names of key(s) of the table.  Providing multiple keys will create a composite key.
# Keys are not required for in-memory tables (though they are still very useful)
[string[]]
$Key,

# The rows of the table.
[Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline)]
[Alias('Rows')]
[PSObject[]]
$Row
)

# A pair of our parameters go straight to the constructor
$constructorArgs = @(
    if ($TableName) {$TableName}
    if ($TableNamespace) {$TableNamespace}
)

# Create the table
$newDataTable = [Data.DataTable]::new.Invoke($constructorArgs)
if ($prefix) {
    $newDataTable.Prefix = $prefix
}

if ($Column) {
    foreach ($newColumn in $Column) {
        if ($newColumn -is [Data.DataColumn]) {
            if ($newDataTable.Columns.Count -and 
                $newDataTable.Columns[$newColumn.ColumnName]) {
                continue
            }
            $null = $newDataTable.Columns.Add($newColumn)
        }        
    }    
}

if ($key -and $column) {
    $newDataTable.PrimaryKey = $newDataTable.Columns[$key]
}


if ($row) {    
    $null = $newDataTable.Import($row)
}
return , $newDataTable



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.CLIXML</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a data table as Clixml
.DESCRIPTION
    Gets a Clixml representation of the rows in a data table.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
[Management.Automation.PSSerializer]::Serialize(
    @($this | Select-Object -Property $columnNames), $FormatEnumerationLimit
)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.CSV</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as CSV
.DESCRIPTION
    Gets a CSV representation of a DataTable.
#&gt;
param()


function toCsv {
    param([string[]]$columns)
    $columns -replace # escape quotes,
        '"','""' -replace # quote items,
        '(?&gt;^|$)','"' -join ',' # join with commas.
}

$myColumns = @($this.Columns.ColumnName)
toCsv $myColumns

foreach ($dataRow in $this.Rows) {
    toCsv $dataRow[$myColumns]
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.JSON</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a data table as JSON
.DESCRIPTION
    Gets a JSON representation of a data table
.NOTES
    The serialization depth can be controlled by setting `$this.SerializationDepth`.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | ConvertTo-Json -Depth $this.SerializationDepth
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.JSONL</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a datatable as JSONL
.DESCRIPTION
    Gets a JSONL representation of a data table.

    JSONL is a format where each line is a JSON object.
.NOTES
    The serialization depth can be controlled by setting `$this.SerializationDepth`.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | . {process { $_  | ConvertTo-Json -Compress -Depth $this.SerializationDepth } }
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.JsonSchema</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as a [JSON schema](https://json-schema.org/).
#&gt;
$jsonSchema = [Ordered]@{
    type = 'object'
    properties = [Ordered]@{}
}
foreach ($column in $this.Columns) {
    $jsonSchema.properties[$column.ColumnName] = [Ordered]@{        
        type = switch ($column.DataType) {
            {$_ -eq [System.String]} { 'string' }
            {$_ -eq [System.Int32]} { 'integer' }
            {$_ -eq [System.Int64]} { 'integer' }
            {$_ -in [Double], [float]} { 'number' }
            {$_ -eq [DateTime]} { 'string' }
            {$_ -eq [Boolean], [switch]} { 'boolean' }
            {$_.IsEnum} { 'enum' }
            default { 'object' }
        }        
    }
    if ($column.DefaultValue -ne [System.DBNull]::Value) {
        $jsonSchema.properties[$column.ColumnName].default = $column.DefaultValue
    }
    if ($column.Caption) {
        $jsonSchema.properties[$column.ColumnName].description = $column.Caption
    }
}
return ($jsonSchema | ConvertTo-Json -Depth 10)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.TSV</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as TSV
.DESCRIPTION
    Gets a Tab Separated Value representation of a DataTable.

    This function will return the DataTable as a TSV string.
#&gt;
param()
function toTSV {
    param([string[]]$columns)
    $columns -replace # escape quotes,
        '"','""' -replace # quote items,
        '(?&gt;^|$)','"' -join "`t" # join with tabs.
}
$myColumns = @($this.Columns.ColumnName)
toTSV $myColumns
foreach ($dataRow in $this.Rows) {
    toTSV $dataRow[$myColumns]
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.XML</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as XML
.DESCRIPTION
    Gets a DataTable as XML, using the `WriteXml` method.
.NOTES
    This property will only return the XML representation of simple DataTables, whose columns are all of simple types.
    
    If this errors out, because it is a property it will simply return nothing.

    To examine the errors, look at `$Error`.
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WriteXml($stringWriter)
$xml = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xml

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.XSD</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as an XML Schema Definition (`.xsd`).
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WritexmlSchema($stringWriter)
$xsd = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xsd

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Unregister</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Unregisters from DataTable events
.DESCRIPTION
    Unregisters on or more subscribers from DataTable events.

    If no subscribers are provided, all subscribers will be unregistered.
#&gt;
param(
# One or more subscribers to unregister .
[Parameter(ValueFromPipelineByPropertyName)]
[PSObject[]]
$Subscriber,

# The table to watch.  If not provided, the current object will be used.
[Data.DataTable[]]
[Alias('DataTables')]
$DataTable
)

if (-not $DataTable -and -not $this) { return }
if ($this -is [Data.DataTable] -and -not $DataTable) {
    $DataTable = $this
} elseif ($this -is [Data.DataTable]) {
    $DataTable += $this
}

if (-not $DataTable.Length) { return }
foreach ($dt in $DataTable) {
    $mySubscriptions = $dt.Subscriber
    if ($Subscriber) {
        foreach ($sub in $Subscriber) {
            $null = [Runspace]::DefaultRunspace.Events.Subscribers.Remove($sub)
        }    
    } else {
        foreach ($sub in $mySubscriptions) {
            $null = [Runspace]::DefaultRunspace.Events.Subscribers.Remove($sub)
        }
    }    
}


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Watch</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Watches a table for changes.
.DESCRIPTION
    Watches data tables for changes, and runs one or more script blocks when the event is triggered.
#&gt;
param(
# One or more events to watch.
[Parameter(ValueFromPipelineByPropertyName)]
[ValidateSet('ColumnChanged', 'ColumnChanging', 'RowChanged', 'RowChanging', 'RowDeleted', 'RowDeleting', 'TableCleared', 'TableClearing', 'TableNewRow')]
[string[]]
$EventName,

# One or more script blocks to run when the event is triggered.
[ScriptBlock[]]
$EventHandler,

# The table to watch.  If not provided, the current object will be used.
[Data.DataTable[]]
[Alias('DataTables')]
$DataTable
)

if (-not $DataTable -and -not $this) { return }
if ($this -is [Data.DataTable] -and -not $DataTable) {
    $DataTable = $this
} elseif ($this -is [Data.DataTable]) {
    $DataTable += $this
}

if (-not $DataTable.Length) { return }

foreach ($dt in $DataTable) {
    $myEvents = @(Get-Member -InputObject $dt -MemberType Event).Name
    foreach ($nameOfEvent in $EventName) {
        if ($nameOfEvent -notin $myEvents) {
            continue
        }
        foreach ($handler in $EventHandler) {
            Register-ObjectEvent -InputObject $dt -EventName $nameOfEvent -Action $handler -SupportEvent
        }
    }
}



                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        return $this.Columns.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>InputScript</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the input script for a DataTable.
.DESCRIPTION
    Dynamically creates a script block that can be used to add rows to a datatable from the pipeline.
#&gt;

param($this = $this)
if (-not $this) { return}
$extendedProperties = [Ordered]@{} + $this.ExtendedProperties
$parameterBlock = @(
    foreach ($dataColumn in $this.Columns) {
        if ($dataColumn.ReadOnly) { continue }
        @(
            $helpLines = $(
                if ($dataColumn.Caption) { $dataColumn.Caption }
                else { $dataColumn.ColumnName }
            ) -split "(?&gt;\r\n|\n)"

            foreach ($helpLine in $helpLines) {                
                "# $helpLine"
            }
            '[Parameter(ValueFromPipelineByPropertyName)]'
            if ($extendedProperties.Aliases -and $extendedProperties.Aliases[$dataColumn.ColumnName] )  {
                "[Alias('$($extendedProperties.Aliases[$dataColumn.ColumnName] -join "','")')]"
            }
            if ($extendedProperties.Patterns -and $extendedProperties.Patterns[$dataColumn.ColumnName]) {
                "[ValidatePattern('$($extendedProperties.Patterns[$dataColumn.ColumnName] -replace "'", "''")')]"
            }
            if ($extendedProperties.Validators -and $extendedProperties.Validators[$dataColumn.ColumnName]) {
                "[ValidateScript({$($extendedProperties.Validators[$dataColumn.ColumnName])})]"
            }
            "[$($dataColumn.DataType.FullName -replace '^System\.')]"
            "`${$($dataColumn.ColumnName)}"
        ) -join [Environment]::NewLine
    }
    @(
        '[Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline,Position=0)]'
        '[PSObject[]]'
        '$InputObject'
    ) -join [Environment]::NewLine
) -join (',' + [Environment]::NewLine)
    
$newScriptBlock = ([ScriptBlock]::Create(@"
[CmdletBinding(PositionalBinding=`$false)]
param(
$parameterBlock
)

begin {
    `$rowsAdded = [long]0
    `$ProgressId = Get-Random
    `$barberPollProgress = 0
    if (`$myInvocation.MyCommand.ScriptBlock.ThisIs) {
        `$local:this = `$myInvocation.MyCommand.ScriptBlock.ThisIs
    }
    `$progressInterval = if (`$this.ProgressInterval -ge 0) { `$this.ProgressInterval } else { 4kb }
    `$NextProgressInterval = `$ProgressInterval
}

process {$({
    $myCommandMetadata = [Management.Automation.CommandMetadata]$MyInvocation.MyCommand
    
        
    $inputObjects = @($input)
    if (-not $inputObjects -and $inputObject.Length) { $inputObjects = $inputObject }
    if (-not $inputObjects) {
        $inputObjects = @([PSCustomObject]([Ordered]@{} + $PSBoundParameters))
    }    

    foreach ($inObject in $inputObjects) {
        $newRow   = if ($local:this -is [Data.DataTable]) {
            $local:this.NewRow()
        }
        foreach ($myParameterName in @($myCommandMetadata.Parameters.Keys)) {         
            if ($newRow.Table -and $newRow.Table.Columns[$myParameterName]) {
                $newRow[$myParameterName] = 
                    if ($null -ne $inObject.$myParameterName) {
                        $inObject.$myParameterName -as $newRow.Table.Columns[$myParameterName].DataType
                    } else {
                        [DBNull]::Value
                    }                
            }
        }
        if ($newRow) {
            if ($progressInterval -and ($rowsAdded -ge $NextProgressInterval)) {
                $NextProgressInterval += $progressInterval
                $multiple = ($NextProgressInterval / $progressInterval)
                while ($multiple -gt 50) { $multiple *= .75 }
                $barberPollProgress = 50 + $multiple
                if ($barberPollProgress -ge 100) { $barberPollProgress = 99 }
                Write-Progress -Id $ProgressId -Activity "Adding rows to Table: '$($this.TableName)'" -Status "$rowsAdded rows" -PercentComplete $barberPollProgress
            }
            $null = $newRow.Table.Rows.Add($newRow)
            
            
            $rowsAdded++
        }
        $inObject
    }
})
}

end {
    if (`$rowsAdded -gt `$progressInterval) {
        Write-Progress -Id `$ProgressId -Activity "Adding rows to Table: '`$(`$this.TableName)'" -Status "`$rowsAdded rows" -Completed
    }
}
"@))
$newScriptBlock.psobject.properties.add([psnoteproperty]::new('ThisIs', $this), $true)
    
return $newScriptBlock



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ProgressInterval</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the progress interval.
.DESCRIPTION
    Gets the progress interval. for a DataTable.

    This is the number of items that should be processed before a progress event is raised.
.NOTES
    By default, this is 8kb.
#&gt;
if (-not $this) { return }
if (-not $this.'.ProgressInterval') {
    $this.psobject.properties.add([psnoteproperty]::new('.ProgressInterval',8kb), $true)
}
return $this.'.ProgressInterval'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the progress interval.
.DESCRIPTION
    Sets the progress interval for a DataTable.

    This is the number of items that should be processed before a progress event is raised.
.NOTES
    By default, this is 8kb.
#&gt;
param([int]$ProgressInterval = 8kb)
if (-not $this) { return }
$this.psobject.properties.add([psnoteproperty]::new('.ProgressInterval',$ProgressInterval), $true)
return $this.'.ProgressInterval'
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        return $this.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>SerializationDepth</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the serialization depth
.DESCRIPTION
    Gets the serialization depth for a DataTable.

    This is the -Depth parameter passed to any serializer that is used to serialize the DataTable.
.NOTES
    By default, this is the `$FormatEnumerationLimit + 1`.
#&gt;
if (-not $this) { return }
if (-not $this.'.SerializationDepth') {
    $this.psobject.properties.add([psnoteproperty]::new('.SerializationDepth',($FormatEnumerationLimit + 1)), $true)
}
return $this.'.SerializationDepth'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the serialization depth
.DESCRIPTION
    Sets the serialization depth for a DataTable.

    This is the -Depth parameter passed to any serializer that is used to serialize the DataTable.
.NOTES
    By default, this is `$FormatEnumerationLimit + 1`.
#&gt;
param([int]$Depth)

if (-not $this) { return }

$this.psobject.properties.add([psnoteproperty]::new('.SerializationDepth',$Depth), $true)
return $this.'.SerializationDepth'
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Subscriber</Name>
        <GetScriptBlock>
                        param()

if (-not $this) { return }
@(foreach ($eventSubscriber in [Runspace]::DefaultRunspace.Events.Subscribers) {
    if ($eventSubscriber.SourceObject.GetHashCode() -eq $this.GetHashCode()) {        
        $eventSubscriber
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataTable</Name>
    <Members>
      <AliasProperty>
        <Name>Count</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Length</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Subscribers</Name>
        <ReferencedMemberName>Subscriber</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Import</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports data into a data table
.DESCRIPTION
    Imports data into a data table.
.NOTES
    If columns do not yet exist, they will be created based on the properties of the input objects.
#&gt;
param()

# Collect all input rows (arguments and piped input)
$arguments = @($args)
$pipedInput = @($input)

$allInputRows = @() + $arguments + $pipedInput

# If this was not a table
$aTable = $this
if ($aTable -isnot [Data.DataTable]) {
    # make a table.
    $aTable = [Data.DataTable]::new()
}

# Walk over each unrolled row in the table.
:nextRow foreach ($inputRow in $allInputRows | . { process { $_}}) {
    # Skip empty values.
    if ($null -eq $inputRow -or [DBNull]::Value -eq $inputRow) { continue nextRow }
    # If a "row" was really a column, add it to the table.
    if ($inputRow -is [Data.DataColumn]) {
        $null = $aTable.Columns.Add($inputRow)
        continue nextRow
    }
    $newInputRow = $aTable.NewRow()
    # If it was already a .NET DataRow, add it to the table.
    if ($inputRow -is [Data.DataRow]) {
        # Of course, don't forget to add it's columns, first.
        foreach ($column in $inputRow.Table.Columns) {
            if (-not ($aTable.Columns.Count -and $aTable.Columns[$column.ColumnName])) {
                $null = $aTable.Columns.Add($column.ColumnName, $column.DataType)    
            }
            $columnAsType = $inputRow[$column.ColumnName] -as $aTable.Columns[$column.ColumnName].DataType
            if (-not $columnAsType) { $columnAsType = [DBNull]::Value }
            $newInputRow[$column.ColumnName] = $columnAsType
        }
        $null = $aTable.Rows.Add($newInputRow)
        continue nextRow
    }
    
    $inputRowTypeNames = $inputRow.pstypenames
    :nextProperty foreach ($rowProperty in $inputRow.psobject.properties) {
        # Skip static properties from the extended type system
        if (-not $rowProperty.IsInstance) { continue nextProperty }

        if ($aTable.Columns.Count -and $aTable.Columns[$rowProperty.Name]) {
            try {
                $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
            } catch {
                $ex = $_
                Write-Warning "Failed to set value for $($rowProperty.Name): $ex"
            }
            
            continue nextProperty
        }
        
        if ($null -ne $rowProperty.Value) {
            $rowPropertyType = $rowProperty.Value.GetType()
            if ($rowPropertyType.FullName -match '\.PS(?:Custom)Object') {
                $rowPropertyType = [object]
            }
            
            $null = $aTable.Columns.Add($rowProperty.Name, $rowPropertyType)
        } else {
            $null = $aTable.Columns.Add($rowProperty.Name, [object])
        }

        $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
    }    
    $null = $aTable.Rows.Add($newInputRow)
}
$aTable.AcceptChanges()
return ,$aTable
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new table
.DESCRIPTION
    Creates a new data table.
#&gt;
param(
# The name of the table.
[string]
$TableName,

# The namespace of the table.
[string]
$TableNamespace,

# The prefix of the table.
# This is used to shorten references to the table if is serialized to XML.
[string]
$TablePrefix,

# The columns of the table.
[Alias('Columns')]
[PSObject[]]
$Column,

# The names of key(s) of the table.  Providing multiple keys will create a composite key.
# Keys are not required for in-memory tables (though they are still very useful)
[string[]]
$Key,

# The rows of the table.
[Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline)]
[Alias('Rows')]
[PSObject[]]
$Row
)

# A pair of our parameters go straight to the constructor
$constructorArgs = @(
    if ($TableName) {$TableName}
    if ($TableNamespace) {$TableNamespace}
)

# Create the table
$newDataTable = [Data.DataTable]::new.Invoke($constructorArgs)
if ($prefix) {
    $newDataTable.Prefix = $prefix
}

if ($Column) {
    foreach ($newColumn in $Column) {
        if ($newColumn -is [Data.DataColumn]) {
            if ($newDataTable.Columns.Count -and 
                $newDataTable.Columns[$newColumn.ColumnName]) {
                continue
            }
            $null = $newDataTable.Columns.Add($newColumn)
        }        
    }    
}

if ($key -and $column) {
    $newDataTable.PrimaryKey = $newDataTable.Columns[$key]
}


if ($row) {    
    $null = $newDataTable.Import($row)
}
return , $newDataTable



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.CLIXML</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a data table as Clixml
.DESCRIPTION
    Gets a Clixml representation of the rows in a data table.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
[Management.Automation.PSSerializer]::Serialize(
    @($this | Select-Object -Property $columnNames), $FormatEnumerationLimit
)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.CSV</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as CSV
.DESCRIPTION
    Gets a CSV representation of a DataTable.
#&gt;
param()


function toCsv {
    param([string[]]$columns)
    $columns -replace # escape quotes,
        '"','""' -replace # quote items,
        '(?&gt;^|$)','"' -join ',' # join with commas.
}

$myColumns = @($this.Columns.ColumnName)
toCsv $myColumns

foreach ($dataRow in $this.Rows) {
    toCsv $dataRow[$myColumns]
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.JSON</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a data table as JSON
.DESCRIPTION
    Gets a JSON representation of a data table
.NOTES
    The serialization depth can be controlled by setting `$this.SerializationDepth`.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | ConvertTo-Json -Depth $this.SerializationDepth
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.JSONL</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a datatable as JSONL
.DESCRIPTION
    Gets a JSONL representation of a data table.

    JSONL is a format where each line is a JSON object.
.NOTES
    The serialization depth can be controlled by setting `$this.SerializationDepth`.
#&gt;
param()
if ($this -isnot [Data.DataTable]) { return }
if (-not $this.Columns.Count) { return }
$columnNames = @($this.Columns.ColumnName)
$this | Select-Object -Property $columnNames | . {process { $_  | ConvertTo-Json -Compress -Depth $this.SerializationDepth } }
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.JsonSchema</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as a [JSON schema](https://json-schema.org/).
#&gt;
$jsonSchema = [Ordered]@{
    type = 'object'
    properties = [Ordered]@{}
}
foreach ($column in $this.Columns) {
    $jsonSchema.properties[$column.ColumnName] = [Ordered]@{        
        type = switch ($column.DataType) {
            {$_ -eq [System.String]} { 'string' }
            {$_ -eq [System.Int32]} { 'integer' }
            {$_ -eq [System.Int64]} { 'integer' }
            {$_ -in [Double], [float]} { 'number' }
            {$_ -eq [DateTime]} { 'string' }
            {$_ -eq [Boolean], [switch]} { 'boolean' }
            {$_.IsEnum} { 'enum' }
            default { 'object' }
        }        
    }
    if ($column.DefaultValue -ne [System.DBNull]::Value) {
        $jsonSchema.properties[$column.ColumnName].default = $column.DefaultValue
    }
    if ($column.Caption) {
        $jsonSchema.properties[$column.ColumnName].description = $column.Caption
    }
}
return ($jsonSchema | ConvertTo-Json -Depth 10)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.TSV</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as TSV
.DESCRIPTION
    Gets a Tab Separated Value representation of a DataTable.

    This function will return the DataTable as a TSV string.
#&gt;
param()
function toTSV {
    param([string[]]$columns)
    $columns -replace # escape quotes,
        '"','""' -replace # quote items,
        '(?&gt;^|$)','"' -join "`t" # join with tabs.
}
$myColumns = @($this.Columns.ColumnName)
toTSV $myColumns
foreach ($dataRow in $this.Rows) {
    toTSV $dataRow[$myColumns]
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.XML</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a DataTable as XML
.DESCRIPTION
    Gets a DataTable as XML, using the `WriteXml` method.
.NOTES
    This property will only return the XML representation of simple DataTables, whose columns are all of simple types.
    
    If this errors out, because it is a property it will simply return nothing.

    To examine the errors, look at `$Error`.
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WriteXml($stringWriter)
$xml = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xml

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>To.XSD</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Gets a schema for a DataTable
.DESCRIPTION
    Gets the schema for a DataTable, as an XML Schema Definition (`.xsd`).
#&gt;
param()
$stringWriter = [IO.StringWriter]::new()
$this.WritexmlSchema($stringWriter)
$xsd = $stringWriter.ToString()
$stringWriter.Close()
$stringWriter.Dispose()
return $xsd

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Unregister</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Unregisters from DataTable events
.DESCRIPTION
    Unregisters on or more subscribers from DataTable events.

    If no subscribers are provided, all subscribers will be unregistered.
#&gt;
param(
# One or more subscribers to unregister .
[Parameter(ValueFromPipelineByPropertyName)]
[PSObject[]]
$Subscriber,

# The table to watch.  If not provided, the current object will be used.
[Data.DataTable[]]
[Alias('DataTables')]
$DataTable
)

if (-not $DataTable -and -not $this) { return }
if ($this -is [Data.DataTable] -and -not $DataTable) {
    $DataTable = $this
} elseif ($this -is [Data.DataTable]) {
    $DataTable += $this
}

if (-not $DataTable.Length) { return }
foreach ($dt in $DataTable) {
    $mySubscriptions = $dt.Subscriber
    if ($Subscriber) {
        foreach ($sub in $Subscriber) {
            $null = [Runspace]::DefaultRunspace.Events.Subscribers.Remove($sub)
        }    
    } else {
        foreach ($sub in $mySubscriptions) {
            $null = [Runspace]::DefaultRunspace.Events.Subscribers.Remove($sub)
        }
    }    
}


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Watch</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Watches a table for changes.
.DESCRIPTION
    Watches data tables for changes, and runs one or more script blocks when the event is triggered.
#&gt;
param(
# One or more events to watch.
[Parameter(ValueFromPipelineByPropertyName)]
[ValidateSet('ColumnChanged', 'ColumnChanging', 'RowChanged', 'RowChanging', 'RowDeleted', 'RowDeleting', 'TableCleared', 'TableClearing', 'TableNewRow')]
[string[]]
$EventName,

# One or more script blocks to run when the event is triggered.
[ScriptBlock[]]
$EventHandler,

# The table to watch.  If not provided, the current object will be used.
[Data.DataTable[]]
[Alias('DataTables')]
$DataTable
)

if (-not $DataTable -and -not $this) { return }
if ($this -is [Data.DataTable] -and -not $DataTable) {
    $DataTable = $this
} elseif ($this -is [Data.DataTable]) {
    $DataTable += $this
}

if (-not $DataTable.Length) { return }

foreach ($dt in $DataTable) {
    $myEvents = @(Get-Member -InputObject $dt -MemberType Event).Name
    foreach ($nameOfEvent in $EventName) {
        if ($nameOfEvent -notin $myEvents) {
            continue
        }
        foreach ($handler in $EventHandler) {
            Register-ObjectEvent -InputObject $dt -EventName $nameOfEvent -Action $handler -SupportEvent
        }
    }
}



                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        return $this.Columns.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>InputScript</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the input script for a DataTable.
.DESCRIPTION
    Dynamically creates a script block that can be used to add rows to a datatable from the pipeline.
#&gt;

param($this = $this)
if (-not $this) { return}
$extendedProperties = [Ordered]@{} + $this.ExtendedProperties
$parameterBlock = @(
    foreach ($dataColumn in $this.Columns) {
        if ($dataColumn.ReadOnly) { continue }
        @(
            $helpLines = $(
                if ($dataColumn.Caption) { $dataColumn.Caption }
                else { $dataColumn.ColumnName }
            ) -split "(?&gt;\r\n|\n)"

            foreach ($helpLine in $helpLines) {                
                "# $helpLine"
            }
            '[Parameter(ValueFromPipelineByPropertyName)]'
            if ($extendedProperties.Aliases -and $extendedProperties.Aliases[$dataColumn.ColumnName] )  {
                "[Alias('$($extendedProperties.Aliases[$dataColumn.ColumnName] -join "','")')]"
            }
            if ($extendedProperties.Patterns -and $extendedProperties.Patterns[$dataColumn.ColumnName]) {
                "[ValidatePattern('$($extendedProperties.Patterns[$dataColumn.ColumnName] -replace "'", "''")')]"
            }
            if ($extendedProperties.Validators -and $extendedProperties.Validators[$dataColumn.ColumnName]) {
                "[ValidateScript({$($extendedProperties.Validators[$dataColumn.ColumnName])})]"
            }
            "[$($dataColumn.DataType.FullName -replace '^System\.')]"
            "`${$($dataColumn.ColumnName)}"
        ) -join [Environment]::NewLine
    }
    @(
        '[Parameter(ValueFromPipelineByPropertyName,ValueFromPipeline,Position=0)]'
        '[PSObject[]]'
        '$InputObject'
    ) -join [Environment]::NewLine
) -join (',' + [Environment]::NewLine)
    
$newScriptBlock = ([ScriptBlock]::Create(@"
[CmdletBinding(PositionalBinding=`$false)]
param(
$parameterBlock
)

begin {
    `$rowsAdded = [long]0
    `$ProgressId = Get-Random
    `$barberPollProgress = 0
    if (`$myInvocation.MyCommand.ScriptBlock.ThisIs) {
        `$local:this = `$myInvocation.MyCommand.ScriptBlock.ThisIs
    }
    `$progressInterval = if (`$this.ProgressInterval -ge 0) { `$this.ProgressInterval } else { 4kb }
    `$NextProgressInterval = `$ProgressInterval
}

process {$({
    $myCommandMetadata = [Management.Automation.CommandMetadata]$MyInvocation.MyCommand
    
        
    $inputObjects = @($input)
    if (-not $inputObjects -and $inputObject.Length) { $inputObjects = $inputObject }
    if (-not $inputObjects) {
        $inputObjects = @([PSCustomObject]([Ordered]@{} + $PSBoundParameters))
    }    

    foreach ($inObject in $inputObjects) {
        $newRow   = if ($local:this -is [Data.DataTable]) {
            $local:this.NewRow()
        }
        foreach ($myParameterName in @($myCommandMetadata.Parameters.Keys)) {         
            if ($newRow.Table -and $newRow.Table.Columns[$myParameterName]) {
                $newRow[$myParameterName] = 
                    if ($null -ne $inObject.$myParameterName) {
                        $inObject.$myParameterName -as $newRow.Table.Columns[$myParameterName].DataType
                    } else {
                        [DBNull]::Value
                    }                
            }
        }
        if ($newRow) {
            if ($progressInterval -and ($rowsAdded -ge $NextProgressInterval)) {
                $NextProgressInterval += $progressInterval
                $multiple = ($NextProgressInterval / $progressInterval)
                while ($multiple -gt 50) { $multiple *= .75 }
                $barberPollProgress = 50 + $multiple
                if ($barberPollProgress -ge 100) { $barberPollProgress = 99 }
                Write-Progress -Id $ProgressId -Activity "Adding rows to Table: '$($this.TableName)'" -Status "$rowsAdded rows" -PercentComplete $barberPollProgress
            }
            $null = $newRow.Table.Rows.Add($newRow)
            
            
            $rowsAdded++
        }
        $inObject
    }
})
}

end {
    if (`$rowsAdded -gt `$progressInterval) {
        Write-Progress -Id `$ProgressId -Activity "Adding rows to Table: '`$(`$this.TableName)'" -Status "`$rowsAdded rows" -Completed
    }
}
"@))
$newScriptBlock.psobject.properties.add([psnoteproperty]::new('ThisIs', $this), $true)
    
return $newScriptBlock



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ProgressInterval</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the progress interval.
.DESCRIPTION
    Gets the progress interval. for a DataTable.

    This is the number of items that should be processed before a progress event is raised.
.NOTES
    By default, this is 8kb.
#&gt;
if (-not $this) { return }
if (-not $this.'.ProgressInterval') {
    $this.psobject.properties.add([psnoteproperty]::new('.ProgressInterval',8kb), $true)
}
return $this.'.ProgressInterval'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the progress interval.
.DESCRIPTION
    Sets the progress interval for a DataTable.

    This is the number of items that should be processed before a progress event is raised.
.NOTES
    By default, this is 8kb.
#&gt;
param([int]$ProgressInterval = 8kb)
if (-not $this) { return }
$this.psobject.properties.add([psnoteproperty]::new('.ProgressInterval',$ProgressInterval), $true)
return $this.'.ProgressInterval'
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        return $this.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>SerializationDepth</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the serialization depth
.DESCRIPTION
    Gets the serialization depth for a DataTable.

    This is the -Depth parameter passed to any serializer that is used to serialize the DataTable.
.NOTES
    By default, this is the `$FormatEnumerationLimit + 1`.
#&gt;
if (-not $this) { return }
if (-not $this.'.SerializationDepth') {
    $this.psobject.properties.add([psnoteproperty]::new('.SerializationDepth',($FormatEnumerationLimit + 1)), $true)
}
return $this.'.SerializationDepth'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the serialization depth
.DESCRIPTION
    Sets the serialization depth for a DataTable.

    This is the -Depth parameter passed to any serializer that is used to serialize the DataTable.
.NOTES
    By default, this is `$FormatEnumerationLimit + 1`.
#&gt;
param([int]$Depth)

if (-not $this) { return }

$this.psobject.properties.add([psnoteproperty]::new('.SerializationDepth',$Depth), $true)
return $this.'.SerializationDepth'
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Subscriber</Name>
        <GetScriptBlock>
                        param()

if (-not $this) { return }
@(foreach ($eventSubscriber in [Runspace]::DefaultRunspace.Events.Subscribers) {
    if ($eventSubscriber.SourceObject.GetHashCode() -eq $this.GetHashCode()) {        
        $eventSubscriber
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>