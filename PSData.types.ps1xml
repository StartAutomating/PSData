<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>PSDataSet</Name>
    <Members>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the table names
.DESCRIPTION
    Gets the table names from the data set.
.NOTES
    When the table names are enumerated, they are added as properties to the data set.
    This makes it easier to access tables by name.
#&gt;
@(foreach ($dataTable in $this.Tables) {
    $dataTable.TableName
    if (-not $this.psobject.properties[$dataTable.TableName]) {
        $this.psobject.properties.Add([psnoteproperty]::new($dataTable.TableName, $dataTable), $true)
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataSet</Name>
    <Members>
      <ScriptProperty>
        <Name>TableName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the table names
.DESCRIPTION
    Gets the table names from the data set.
.NOTES
    When the table names are enumerated, they are added as properties to the data set.
    This makes it easier to access tables by name.
#&gt;
@(foreach ($dataTable in $this.Tables) {
    $dataTable.TableName
    if (-not $this.psobject.properties[$dataTable.TableName]) {
        $this.psobject.properties.Add([psnoteproperty]::new($dataTable.TableName, $dataTable), $true)
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSDataTable</Name>
    <Members>
      <AliasProperty>
        <Name>Count</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Length</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Subscribers</Name>
        <ReferencedMemberName>Subscriber</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Import</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports data into a data table
.DESCRIPTION
    Imports data into a data table.
.NOTES
    If columns do not yet exist, they will be created based on the properties of the input objects.
#&gt;
param()

# Collect all input rows (arguments and piped input)
$arguments = @($args)
$pipedInput = @($input)

$allInputRows = @(
    $arguments | . { process { $_} }
    $pipedInput | . { process { $_} }
)

# If this was not a table
$aTable = $this
if ($aTable -isnot [Data.DataTable]) {
    # make a table.
    $aTable = [Data.DataTable]::new()
}

# Walk over each row in the table.
:nextRow foreach ($inputRow in $allInputRows) {
    if ($inputRow -is [Data.DataColumn]) {
        $null = $aTable.Columns.Add($inputRow)
        continue nextRow
    }    
    $newInputRow = $aTable.NewRow()
    $inputRowTypeNames = $inputRow.pstypenames
    :nextProperty foreach ($rowProperty in $inputRow.psobject.properties) {
        # Skip static properties from the extended type system
        if (-not $rowProperty.IsInstance) { continue nextProperty }

        if ($aTable.Columns.Count -and $aTable.Columns[$rowProperty.Name]) {
            try {
                $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
            } catch {
                $ex = $_
                Write-Warning "Failed to set value for $($rowProperty.Name): $ex"
            }
            
            continue nextProperty
        }
        
        if ($null -ne $rowProperty.Value) {
            $rowPropertyType = $rowProperty.Value.GetType()
            if ($rowPropertyType.FullName -match '\.PS(?:Custom)Object') {
                $rowPropertyType = [object]
            }
            
            $null = $aTable.Columns.Add($rowProperty.Name, $rowPropertyType)
        } else {
            $null = $aTable.Columns.Add($rowProperty.Name, [object])
        }

        $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
    }    
    $null = $aTable.Rows.Add($newInputRow)
}
$aTable.AcceptChanges()
return ,$aTable
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        return $this.Columns.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        return $this.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Subscriber</Name>
        <GetScriptBlock>
                        param()

@(foreach ($eventSubscriber in Get-EventSubscriber) {
    if ($eventSubscriber.SourceObject.GetHashCode() -eq $this.GetHashCode()) {        
        $eventSubscriber
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Data.DataTable</Name>
    <Members>
      <AliasProperty>
        <Name>Count</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Length</Name>
        <ReferencedMemberName>RowCount</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Subscribers</Name>
        <ReferencedMemberName>Subscriber</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Import</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports data into a data table
.DESCRIPTION
    Imports data into a data table.
.NOTES
    If columns do not yet exist, they will be created based on the properties of the input objects.
#&gt;
param()

# Collect all input rows (arguments and piped input)
$arguments = @($args)
$pipedInput = @($input)

$allInputRows = @(
    $arguments | . { process { $_} }
    $pipedInput | . { process { $_} }
)

# If this was not a table
$aTable = $this
if ($aTable -isnot [Data.DataTable]) {
    # make a table.
    $aTable = [Data.DataTable]::new()
}

# Walk over each row in the table.
:nextRow foreach ($inputRow in $allInputRows) {
    if ($inputRow -is [Data.DataColumn]) {
        $null = $aTable.Columns.Add($inputRow)
        continue nextRow
    }    
    $newInputRow = $aTable.NewRow()
    $inputRowTypeNames = $inputRow.pstypenames
    :nextProperty foreach ($rowProperty in $inputRow.psobject.properties) {
        # Skip static properties from the extended type system
        if (-not $rowProperty.IsInstance) { continue nextProperty }

        if ($aTable.Columns.Count -and $aTable.Columns[$rowProperty.Name]) {
            try {
                $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
            } catch {
                $ex = $_
                Write-Warning "Failed to set value for $($rowProperty.Name): $ex"
            }
            
            continue nextProperty
        }
        
        if ($null -ne $rowProperty.Value) {
            $rowPropertyType = $rowProperty.Value.GetType()
            if ($rowPropertyType.FullName -match '\.PS(?:Custom)Object') {
                $rowPropertyType = [object]
            }
            
            $null = $aTable.Columns.Add($rowProperty.Name, $rowPropertyType)
        } else {
            $null = $aTable.Columns.Add($rowProperty.Name, [object])
        }

        $newInputRow[$rowProperty.Name] = $rowProperty.Value -as $aTable.Columns[$rowProperty.Name].DataType
    }    
    $null = $aTable.Rows.Add($newInputRow)
}
$aTable.AcceptChanges()
return ,$aTable
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        return $this.Columns.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        return $this.Rows.Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Subscriber</Name>
        <GetScriptBlock>
                        param()

@(foreach ($eventSubscriber in Get-EventSubscriber) {
    if ($eventSubscriber.SourceObject.GetHashCode() -eq $this.GetHashCode()) {        
        $eventSubscriber
    }
})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>